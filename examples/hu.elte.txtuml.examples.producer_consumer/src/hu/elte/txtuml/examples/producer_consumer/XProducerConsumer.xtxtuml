package hu.elte.txtuml.examples.producer_consumer;

import hu.elte.txtuml.api.^model.ModelExecutor;
import hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Item
import hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Producer
import hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Consumer
import hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Storage
import hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Production
import hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Consumption

model XProducerConsumer {
	
	signal DoWork;
	signal Acknowledgement;
	
	class Producer {
		int toProduce;
		Producer(int num) {
			toProduce = num;
		}
		
		Item produce() {
			this.toProduce--;
			send new DoWork() to Producer.this;
			return new Item();
		}
		
		initial Init;
		state Active;
		state Passive {
			entry {
				hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Storage storage = Producer.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::Production::storage.selectAny();
				unlink(hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Production.producer, Producer.this, hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Production.storage, storage);
				delete Producer.this;
			}
		}
		
		transition Initialize {
			from Init;
			to Active;
			effect {
				send new DoWork() to Producer.this;
			}
		}
		
		transition DoOffer {
			from Active;
			to Active;
			trigger DoWork;
			guard (Producer.this.toProduce > 0);
			effect {
				hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Storage storage = Producer.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::Production::storage.selectAny();
				link(hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Offer.producer, Producer.this, hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Offer.storage, storage);
				send new OfferNotification() to storage;
			}
		}
		
		transition Stop {
			from Active;
			to Passive;
			trigger DoWork;
			guard (Producer.this.toProduce <= 0);
		}
	}
	
	class Consumer {
		int toConsume;
		Consumer(int toConsume) {
			this.toConsume = toConsume;
		}
		
		void consume(Item item) {
			toConsume--;
			send new DoWork() to Consumer.this;
		}
		
		initial Init;
		state Active;
		state Passive {
			entry {
				hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Storage storage = Consumer.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::Consumption::storage.selectAny();
				unlink(hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Consumption.consumer, Consumer.this, hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Consumption.storage, storage);
				delete Consumer.this;
			}
		}
		
		transition Initialize {
			from Init;
			to Active;
			effect {
				send new DoWork() to Consumer.this;
			}
		}
		
		transition DoRequest {
			from Active;
			to Active;
			trigger DoWork;
			guard (Consumer.this.toConsume > 0)
			effect {
				hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Storage storage = Consumer.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::Consumption::storage.selectAny();
				link(hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Request.storage, storage, hu.elte.txtuml.examples.producer_consumer.XProducerConsumer.Request.consumer, Consumer.this);
				send new RequestNotification() to storage;
			}
		}
		
		transition Stop {
			from Active;
			to Passive;
			trigger DoWork;
			guard (Consumer.this.toConsume <= 0);
		}
	}
	
	signal OfferNotification;
	signal RequestNotification;
	
	class Storage {
		int capacity;
		
		Storage(int capacity) {
			this.capacity = capacity;
		}
		
		initial Init;
		state Working;
		
		transition Initialize {
			from Init;
			to Working;
		}
		
		transition CanAccept {
			from Working;
			to Working;
			trigger OfferNotification;
			guard(Storage.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::InStore::item.count() < capacity);
			effect {
				Producer producer = Storage.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::Offer::producer.selectAny();
				unlink(Offer.producer, producer, Offer.storage, Storage.this);
				Item item = producer.produce();
				link(InStore.storage, Storage.this, InStore.item, item);
			}
		}
		
		transition CannotAccept {
			from Working;
			to Working;
			trigger OfferNotification;
			guard(Storage.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::InStore::item.count() >= capacity);
			effect {
				// postpone the offer
				send new OfferNotification() to Storage.this;
			}
		}

		transition CanServe {
			from Working;
			to Working;
			trigger RequestNotification;
			guard(Storage.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::InStore::item.count() > 0);
			effect {
				Consumer consumer = Storage.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::Request::consumer.selectAny();
				unlink(Request.storage, Storage.this, Request.consumer, consumer);
				Item item = Storage.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::InStore::item.selectAny();
				unlink(InStore.storage, Storage.this, InStore.item, item);
				consumer.consume(item);
			}
		}
		
		transition CannotServe {
			from Working;
			to Working;
			trigger RequestNotification;
			guard(Storage.this->hu::elte::txtuml::examples::producer_consumer::XProducerConsumer::InStore::item.count() <= 0);
			effect {
				// postpone the request
				send new RequestNotification() to Storage.this;
			}
		}
		
	}
	
	class Item;
	
	association Production {
		* Producer producer;
		1 Storage storage;
	}
	
	association Offer {
		* Producer producer;
		0..1 Storage storage;
	}

	association Consumption {
		1 Storage storage;
		* Consumer consumer;
	}
	
	association Request {
		0..1 Storage storage;
		* Consumer consumer;
	}
	
	association InStore {
		* Item item;
		0..1 Storage storage;
	}
}

execution XProducerConsumerTester {
	ModelExecutor.Settings.setExecutorLog(true);

	Storage storage = create(Storage,2);
	Producer p1 = create(Producer,3);
	Producer p2 = create(Producer,3);
	Consumer c1 = create(Consumer,2);
	Consumer c2 = create(Consumer,2);
	Consumer c3 = create(Consumer,2);

	link(Production.producer, p1, Production.storage, storage);
	link(Production.producer, p2, Production.storage, storage);
	link(Consumption.consumer, c1, Consumption.storage, storage);
	link(Consumption.consumer, c2, Consumption.storage, storage);
	link(Consumption.consumer, c3, Consumption.storage, storage);

	start(storage);
	start(p1);
	start(p2);
	start(c1);
	start(c2);
	start(c3);

	ModelExecutor.shutdown();
}